<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Virigl,mrchan3668@gmail.com"><title>ReactNative 运行原理 · Virgil Chan</title><meta name="description" content="之前在研究 RN -&amp;gt; Web 的时候，发现我对 RN 的理解还不够清晰，所以拿源码翻了一下，记录一下心得。
RN 版本：0.60.5
原理我们前端写的 React 会被转换成 JS 语法，打成一个 JSBundle 包，在 App 内被加载和执行，通过 Bridge 将指令发送给 Nativ"><meta name="keywords" content="HTML,CSS,JavaScript,Vue,AngularJS,WebPack,UnderScore,System,Raspberry,Tool,Linux,WordPress,NodeJS,MongoDB,Git,Python"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="manifest" href="/manifest.json"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/favicon.png" style="width:127px;"><h3 title><a href="/">Virgil Chan</a></h3><div class="description"><p>间歇性凌云壮志，持续性混吃等死</p></div></div></div><ul class="social-links"><li><a href="http://www.feed43.com/6708067855351261.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/1953548815"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/pansy-cx"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>ReactNative 运行原理</a></h3></div><div class="post-content"><p>之前在研究 RN -&gt; Web 的时候，发现我对 RN 的理解还不够清晰，所以拿源码翻了一下，记录一下心得。</p>
<p>RN 版本：0.60.5</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们前端写的 React 会被转换成 JS 语法，打成一个 JSBundle 包，在 App 内被加载和执行，通过 Bridge 将指令发送给 Native 执行。Bridge 将消息转为 JSON，通过异步的方式在两端传递消息。</p>
<p><img src="https://formidable.com/uploads/old-diagram-full.png" alt></p>
<p>之前 RN 的架构确实如此，网上很多19年之前的文章也都是这么说的，导致我一开始看代码就搞错了思路。实际上 RN 在 0.58 之后的版本使用 JSI 取代了先前的 Bridge。</p>
<p><img src="https://formidable.com/uploads/new-5.png" alt></p>
<p>这个 JSI 是由 C++ 实现的，可以认为 JSI 是一个简单版的 JS 引擎接口，同时连接 JS 和 Native，可以让 JS 保存对 c++ Host Object 的引用，也就是说不用将传递的消息序列化到 JSON，实现 JS 和 Native 的同步通信。</p>
<blockquote>
<p>摘自 RN 开发人员写的一篇解释 RN 新架构的上层设计方案 <a href="https://formidable.com/blog/2019/jsi-jsc-part-2/" target="_blank" rel="noopener">https://formidable.com/blog/2019/jsi-jsc-part-2/</a></p>
<p>The second improvement—arguably the cornerstone of the whole re-architecture—is that “by using JSI, JavaScript can hold reference to C++ Host Objects and invoke methods on them.” This means that, finally, we are tackling the core issue explained in the previous article: the two realms of JavaScript and Native will be <strong>really</strong> aware of each other, and there won’t be any need to serialize to JSON the messages to pass across, removing all congestion on the bridge (we’ll explore this more in the next article).</p>
</blockquote>
<p>所以整个 RN 的执行流程就是：</p>
<ol>
<li>初始化：View/Bridge -&gt; 加载/执行 JSBundle -&gt; Bridge(JSI) -&gt; Native</li>
<li>运行时：(e.g) 触摸屏幕 -&gt; Native EventListen -&gt; Bridge(JSI) -&gt; JS xxxx -&gt; Bridge(JSI) ……</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">  RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:<span class="keyword">self</span> launchOptions:launchOptions];</span><br><span class="line">  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge</span><br><span class="line">                                                   moduleName:<span class="string">@"demo"</span></span><br><span class="line">                                            initialProperties:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">  rootView.backgroundColor = [[<span class="built_in">UIColor</span> alloc] initWithRed:<span class="number">1.0</span>f green:<span class="number">1.0</span>f blue:<span class="number">1.0</span>f alpha:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">  <span class="built_in">UIViewController</span> *rootViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">  rootViewController.view = rootView;</span><br><span class="line">  <span class="keyword">self</span>.window.rootViewController = rootViewController;</span><br><span class="line">  [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>RCTRootView</p>
<p>RN 的根页面，所有在 RN 端写的 component 都将转为 Native View 挂载到 RCTRootView 之上。</p>
<p>在 RN 初始化创建的项目，RCTRootView 直接挂在 <code>window.rootViewController</code> 上，可以想象成 html 的 <code>&lt;body&gt;</code>。</p>
</li>
<li><p>RCTBridge</p>
<p>RCTBridge 实例化一个 bridge，作为 OC 与 JS 交互的桥梁，它还有另一个实例化的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithBundleURL:(<span class="built_in">NSURL</span> *)bundleURL</span><br><span class="line">                   moduleProvider:(RCTBridgeModuleListProvider)block</span><br><span class="line">                    launchOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="RCTBridge"><a href="#RCTBridge" class="headerlink" title="RCTBridge"></a>RCTBridge</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7vh5z731jj30q80ggaah.jpg" alt="RN 启动流程"></p>
<h5 id="1-setUp"><a href="#1-setUp" class="headerlink" title="#1. setUp"></a>#1. setUp</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUp</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">self</span>.batchedBridge = [[[RCTCxxBridge <span class="keyword">class</span>] alloc] initWithParentBridge:<span class="keyword">self</span>];</span><br><span class="line">  [<span class="keyword">self</span>.batchedBridge start];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>略过 Logger，RCTBridge 实际上没做什么事，只实例化了 RCTCxxBridge 并持有了它，大部分的初始化逻辑都在  <code>[batchedBridge start]</code> 完成。</p>
<h5 id="2-start"><a href="#2-start" class="headerlink" title="#2. start"></a>#2. start</h5><p><code>.mm</code> 后缀表示除了 Objc 还可以运行 C++。<code>RCTCxxBridge.mm</code> 混合了 Objc 和 C++。</p>
<p>对代码做了简化处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RCTCxxBridge.mm</span></span><br><span class="line">- (<span class="keyword">void</span>)start</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 通知</span></span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">    postNotificationName:RCTJavaScriptWillStartLoadingNotification</span><br><span class="line">    object:_parentBridge userInfo:@&#123;<span class="string">@"bridge"</span>: <span class="keyword">self</span>&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the JS thread early</span></span><br><span class="line">  <span class="comment">// 开一个线程给 JS 使用</span></span><br><span class="line">  _jsThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:[<span class="keyword">self</span> <span class="keyword">class</span>]</span><br><span class="line">                                      selector:<span class="keyword">@selector</span>(runRunLoop)</span><br><span class="line">                                        object:<span class="literal">nil</span>];</span><br><span class="line">  _jsThread.name = <span class="string">@"com.facebook.react.JavaScript"</span>;</span><br><span class="line">  <span class="comment">// 线程最高优先级，用于用户交互事件</span></span><br><span class="line">  _jsThread.qualityOfService = <span class="built_in">NSQualityOfServiceUserInteractive</span>;</span><br><span class="line">  [_jsThread start];</span><br><span class="line"></span><br><span class="line">  dispatch_group_t prepareBridge = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  [_performanceLogger markStartForTag:RCTPLNativeModuleInit];</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> registerExtraModules];</span><br><span class="line">  <span class="comment">// Initialize all native modules that cannot be loaded lazily</span></span><br><span class="line">  <span class="comment">// 加载 JS 调用 Native 模块</span></span><br><span class="line">  (<span class="keyword">void</span>)[<span class="keyword">self</span> _initializeModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:<span class="literal">NO</span>];</span><br><span class="line">  [<span class="keyword">self</span> registerExtraLazyModules];</span><br><span class="line"></span><br><span class="line">  __<span class="keyword">weak</span> RCTCxxBridge *weakSelf = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dispatch the instance initialization as soon as the initial module metadata has</span></span><br><span class="line">  <span class="comment">// been collected (see initModules)</span></span><br><span class="line">  <span class="comment">// 确定是否在 JS 线程，如果不是，指定在 JS 线程操作</span></span><br><span class="line">  dispatch_group_enter(prepareBridge);</span><br><span class="line">  [<span class="keyword">self</span> ensureOnJavaScriptThread:^&#123;</span><br><span class="line">    [weakSelf _initializeBridge:executorFactory];</span><br><span class="line">    dispatch_group_leave(prepareBridge);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the source asynchronously, then store it for later execution.</span></span><br><span class="line">  <span class="comment">// 加载资源</span></span><br><span class="line">  dispatch_group_enter(prepareBridge);</span><br><span class="line">  __block <span class="built_in">NSData</span> *sourceCode;</span><br><span class="line">  [<span class="keyword">self</span> loadSource:^(<span class="built_in">NSError</span> *error, RCTSource *source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      [weakSelf handleError:error];</span><br><span class="line">    &#125;</span><br><span class="line">    sourceCode = source.data;</span><br><span class="line">    dispatch_group_leave(prepareBridge);</span><br><span class="line">  &#125; onProgress:^(RCTLoadingProgress *progressData) &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for both the modules and source code to have finished loading</span></span><br><span class="line">  <span class="comment">// 加载完线程和 JS 模块，执行 JS</span></span><br><span class="line">  dispatch_group_notify(prepareBridge, dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, <span class="number">0</span>), ^&#123;</span><br><span class="line">    RCTCxxBridge *strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (sourceCode &amp;&amp; strongSelf.loading) &#123;</span><br><span class="line">      [strongSelf executeSourceCode:sourceCode sync:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要做了 4 件事：</p>
<ol>
<li>jsThread：用于执行 JS 线程，iOS 的 UI 操作必须在主线程操作，如果在 JS 线程执行了一次开销很大的步骤，此时任何由 JS 控制的动画都会卡住，详见官方文档：<a href="https://reactnative.cn/docs/performance/#%E5%85%B3%E4%BA%8E-%E5%B8%A7-%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84" target="_blank" rel="noopener">JS帧率</a>。</li>
<li>加载模块：加载 ReactNative 封装的原生模块，比如 Alert、keyboard 模块以及 SafeArea、Text 等组件模块，支持自定义原生模块（详见 Native 与 RN 通信）。</li>
<li>加载 Bundle 资源：这步没什么好说的，会读取本地的 JSBundle，如果是开发环境，则会从 <code>react-native start</code> 起的静态资源服务器取 Bundle。<code>http://localhost:8081/index.bundle?platform=ios&amp;dev=true&amp;minify=false</code> 可以看到编译后的 JS 代码。</li>
<li>解析 Bundle 资源：2,3 步是异步加载，加载完后执行 4。（详见执行 JS）。</li>
</ol>
<blockquote>
<p><code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code> 是用于异步执行 GCD 的任务组，当所有任务执行完后执行 <code>dispatch_group_notify</code> 。</p>
<p>用 JS 实现就是 const a = new Promise(); const b = new Promise(); Promise.All(a, b).then()…</p>
</blockquote>
<h4 id="执行-JS"><a href="#执行-JS" class="headerlink" title="执行 JS"></a>执行 JS</h4><p>沿着 <code>[strongSelf executeSourceCode:sourceCode sync:NO]</code> 这个方法看下去，都是一些嵌套函数，中间做了一次分包。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># RCTCxxBridge.mm</span></span><br><span class="line">- (<span class="keyword">void</span>)executeApplicationScript:(<span class="built_in">NSData</span> *)script</span><br><span class="line">                             url:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">                           async:(<span class="built_in">BOOL</span>)async</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// try catch 模块，如果 script 不是 JS 则抛出异常。</span></span><br><span class="line">  [<span class="keyword">self</span> _tryAndHandleError:^&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sourceUrlStr = deriveSourceURL(url);</span><br><span class="line">    <span class="keyword">if</span> (isRAMBundle(script)) &#123;</span><br><span class="line">      <span class="meta"># ... </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;_reactInstance) &#123;</span><br><span class="line">      <span class="keyword">self</span>-&gt;_reactInstance-&gt;loadScriptFromString(std::make_unique&lt;<span class="built_in">NSDataBigString</span>&gt;(script),</span><br><span class="line">                                                 sourceUrlStr.UTF8String, !async);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初略看了一下 RN 文档，<a href="https://reactnative.cn/docs/performance/#%E5%90%AF%E7%94%A8-ram-%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">启动RAM格式</a> 应该是类似于分模块加载的优化功能，暂时不去研究。<code>self-&gt;_reactInstance-&gt;loadScriptFromString</code> 这个方法才是真正执行 JS 的函数。</p>
<p>接下来基本上都是 C++ 代码，不用太在意语法，能看懂做什么就行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSIExecutor.cpp</span></span><br><span class="line"><span class="keyword">void</span> JSIExecutor::loadApplicationScript(</span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">const</span> JSBigString&gt; script,</span><br><span class="line">    std::string sourceURL) &#123;</span><br><span class="line">  SystraceSection s(<span class="string">"JSIExecutor::loadApplicationScript"</span>);</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      <span class="string">"nativeModuleProxy"</span>,</span><br><span class="line">      Object::createFromHostObject(</span><br><span class="line">          *runtime_, std::make_shared&lt;NativeModuleProxy&gt;(*<span class="keyword">this</span>)));</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      <span class="string">"nativeFlushQueueImmediate"</span>,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, <span class="string">"nativeFlushQueueImmediate"</span>),</span><br><span class="line">          <span class="number">1</span>,</span><br><span class="line">          [<span class="keyword">this</span>](</span><br><span class="line">              jsi::Runtime &amp;,</span><br><span class="line">              <span class="keyword">const</span> jsi::Value &amp;,</span><br><span class="line">              <span class="keyword">const</span> jsi::Value *args,</span><br><span class="line">              size_t count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">1</span>) &#123;</span><br><span class="line">              throw std::invalid_argument(</span><br><span class="line">                  <span class="string">"nativeFlushQueueImmediate arg count must be 1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            callNativeModules(args[<span class="number">0</span>], <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> Value::undefined();</span><br><span class="line">          &#125;));</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      <span class="string">"nativeCallSyncHook"</span>,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, <span class="string">"nativeCallSyncHook"</span>),</span><br><span class="line">          <span class="number">1</span>,</span><br><span class="line">          [<span class="keyword">this</span>](</span><br><span class="line">              jsi::Runtime &amp;,</span><br><span class="line">              <span class="keyword">const</span> jsi::Value &amp;,</span><br><span class="line">              <span class="keyword">const</span> jsi::Value *args,</span><br><span class="line">              size_t count) &#123; <span class="keyword">return</span> nativeCallSyncHook(args, count); &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (runtimeInstaller_) &#123;</span><br><span class="line">    runtimeInstaller_(*runtime_);</span><br><span class="line">  &#125;</span><br><span class="line">  runtime_-&gt;evaluateJavaScript(</span><br><span class="line">      std::make_unique&lt;BigStringBuffer&gt;(std::move(script)), sourceURL);</span><br><span class="line">  flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runtime_-&gt;global().setProperty</code> 是在 JS 全局对象 <code>global</code> 上注册 Function 或 Object。</p>
<p><code>runtime_-&gt;evaluateJavaScript</code> 则是调用了 iOS 内置的 JavaScript 引擎，解释执行 JS 代码。</p>
<p>而 <code>runtime_</code> 是 JSI 的一个方法(?)，这里就和之前说的 <code>执行 JS -&gt; Bridge(JSI)</code> 连上了。</p>
<p>将来在项目中如果想具体看某个 RN Api 是怎么实现的，就可以顺着这里查下去。</p>
<h3 id="RN-系列文章"><a href="#RN-系列文章" class="headerlink" title="RN 系列文章"></a>RN 系列文章</h3><ul>
<li><a href="https://idmrchan.com/2019/10/14/react-native-principle-02/">Native 与 RN 通信</a></li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-10-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/React-Native/" title="React-Native">React-Native </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://idmrchan.com/2019/10/12/react-native-principle-01/,Virgil Chan,ReactNative 运行原理,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/10/14/react-native-principle-02/" title="Native 与 RN 通信原理">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/07/11/iOS-SDK-configure/" title="iOS SDK 新手搭建指南">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>