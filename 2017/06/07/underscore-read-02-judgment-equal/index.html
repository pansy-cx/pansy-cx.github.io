<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Virigl,mrchan3668@gmail.com"><title>underscore.js 源码之 比较两个数相等 · Virgil Chan</title><meta name="description" content="继续上一篇讲的 underscore.js 判断工具，还剩下 _.isEqual() 方法没讲。_.isEqual() 方法是用来判断两个数「相同」。此时问题来了，相同的定义是什么？是 === 吗，如果仅是这样，那就没有必要写这个函数了。举个例子，1 === new Number(1) 返回的是 f"><meta name="keywords" content="HTML,CSS,JavaScript,Vue,AngularJS,WebPack,UnderScore,System,Raspberry,Tool,Linux,WordPress,NodeJS,MongoDB,Git,Python"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="manifest" href="/manifest.json"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/favicon.png" style="width:127px;"><h3 title><a href="/">Virgil Chan</a></h3><div class="description"><p>间歇性凌云壮志，持续性混吃等死</p></div></div></div><ul class="social-links"><li><a href="http://www.feed43.com/6708067855351261.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/1953548815"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/pansy-cx"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>underscore.js 源码之 比较两个数相等</a></h3></div><div class="post-content"><p>继续上一篇讲的 underscore.js 判断工具，还剩下 <code>_.isEqual()</code> 方法没讲。<br><code>_.isEqual()</code> 方法是用来判断两个数「相同」。此时问题来了，相同的定义是什么？是 === 吗，如果仅是这样，那就没有必要写这个函数了。<br>举个例子，<code>1 === new Number(1)</code> 返回的是 false ，而 <code>isEqual()</code> 方法判定位相等，因为他们都是 <code>[object Number]</code> 类型。<br>在比如 <code>[1] === [1]</code>，在 JS 中也返回 false，这就很没道理不是，在 <code>isEqual()</code> 函数中会对数组进行遍历，比较数组每个数是否相同。<br>在看代码之前，先来复习一下 JS 比较的一些概念。  </p>
<h3 id="JS-的-相等与全等"><a href="#JS-的-相等与全等" class="headerlink" title="JS 的 相等与全等"></a>JS 的 相等与全等</h3><p>相等(==) —&gt; 先转换后比较，全等(===) —&gt; 不转换直接和比较。<br>在进行转换类型中，有如下规则：</p>
<ol>
<li>true -&gt; 1, false -&gt; 0</li>
<li>如果是字符串和数值比较，先将字符串转为数组</li>
<li>如果操作数是对象，则使用 valueOf() 方法转为基本类型在进行判断</li>
<li>null == undefined</li>
<li>NaN != NaN</li>
</ol>
<p>而全等则不进行比较，比如 1 与 new Number(1)。<code>typeof 1 = Number</code> ，<code>typeof new Number(1) = object</code>。所以二者是不相等的。</p>
<p><code>isEqual()</code> 方法则是在「全等」的基础上，在添加了一些规则，比如数组和对象的判断，类型相等根据 <code>toString()</code> 方法来判断等。  </p>
<h3 id="0，-a-和-‘’-a"><a href="#0，-a-和-‘’-a" class="headerlink" title="+0，+a 和 ‘’+a"></a>+0，+a 和 ‘’+a</h3><h5 id="0-0"><a href="#0-0" class="headerlink" title="+0 === -0"></a>+0 === -0</h5><p>在 JS 中 <code>+0 === -0 -&gt; true</code>。而在 isEqual 中则判定为 false<br>至于原因，我想应该是 <code>1/0 = Infinity, 1/-0 = -Infinity</code> 吧。  </p>
<h5 id="a-与-‘’-a"><a href="#a-与-‘’-a" class="headerlink" title="+a 与 ‘’+a"></a>+a 与 ‘’+a</h5><p><code>+a</code> 意思是将变量转为数字，<code>&#39;&#39;+a</code> 则是转为字符串</p>
<p>知道了这些 isEqual() 前半部分的代码就很清晰了      </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 与 b 是否全等，若 a === 0 则需要判断 +0 -0;</span></span><br><span class="line"><span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br><span class="line"><span class="comment">// 如果其中有一个是 null，全等判断</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="literal">null</span> || b === <span class="literal">null</span>) <span class="keyword">return</span> a === b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> type = toString.call(a);</span><br><span class="line"><span class="comment">// 如果 toString() 类型不相等判定为 false</span></span><br><span class="line"><span class="keyword">if</span> (type !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="comment">// 如果是 RegExp 和 String 属性，都可以比较字符串是否相等</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object RegExp]'</span> :</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object String]'</span> :</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// number 类型要考虑 +0 === -0 这种情况</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object number]'</span> :</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / +b : +a === +b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Date 和 Boolean 类型转为数字判断</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object Date]'</span> :</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'[object Boolean]'</span> :</span><br><span class="line">    <span class="keyword">return</span> +a === +b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是函数数组的判断</p>
<h3 id="函数判断"><a href="#函数判断" class="headerlink" title="函数判断"></a>函数判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = toString.call(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isArray) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">'object'</span> || <span class="keyword">typeof</span> b !== <span class="string">'object'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 到这部之前排除非 object 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</span><br><span class="line">    <span class="comment">// 判断是否是同一个 constructor</span></span><br><span class="line">    <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp;</span><br><span class="line">            _.isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor)</span><br><span class="line">            &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组与对象的判断"><a href="#数组与对象的判断" class="headerlink" title="数组与对象的判断"></a>数组与对象的判断</h3><p>数组和对象由于存在多重嵌套，最好的方法就是使用回调函数  </p>
<p>我们在调用函数时，<code>_.isEqual(a,b)</code> 传入两个要比较的函数。而函数实际上定义了 4 个形参 <code>function(a, b, aStack, bStack)</code>; 后两个函数在回调时会被添加，用于线性搜索？这里我也不是恨懂  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aStack = aStack || [];</span><br><span class="line">bStack = bStack || [];</span><br><span class="line"><span class="keyword">var</span> length = aStack.length;</span><br><span class="line"><span class="keyword">while</span> (length--) &#123;</span><br><span class="line">  <span class="comment">// Linear search. Performance is inversely proportional to the number of</span></span><br><span class="line">  <span class="comment">// unique nested structures.</span></span><br><span class="line">  <span class="keyword">if</span> (aStack[length] === a) <span class="keyword">return</span> bStack[length] === b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the first object to the stack of traversed objects.</span></span><br><span class="line">aStack.push(a);</span><br><span class="line">bStack.push(b);</span><br></pre></td></tr></table></figure>
<p>这里不是看得恨懂，不清楚什么结构会调用 while 里面的语句，aStack 储存的是所有的数组元素。先继续往下看  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">    length = a.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        <span class="comment">// 回调，深遍历。同时也传入 aStack 与 bStack</span></span><br><span class="line">        <span class="keyword">if</span>(!_.isEqual(a[length], b[length], aStack, bStack))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对象，同上面数组</span></span><br><span class="line">    <span class="comment">// _.keys 是 underscore 方法，用于储存对象 key 值，返回一个数组</span></span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(a), key;</span><br><span class="line">    length = keys.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length !== _.keys(b).length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        key = keys.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(_.has(b, key) &amp;&amp; _.isEqual(a[key], b[key], aStack, bStack)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>整个代码思想也很好理解，如果是数组，则采用回调传入 a[length] 和 b[length] 进行遍历比较，如果都符合则一路通过，最后输出 true。<br>唯一难理解的是 传入的 aStack <code>if (aStack[length] === a) return bStack[length] === b;</code> 不知道什么样的数组结构才会进行此判断。</p>
<p>That’s all ，underscore源码 <a href="https://github.com/hanzichi/underscore-analysis/blob/master/underscore-1.8.3.js/src/underscore-1.8.3.js#L1094-L1190" target="_blank">这里</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-07</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><a class="tag" href="/tags/UnderScore/" title="UnderScore">UnderScore </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://idmrchan.com/2017/06/07/underscore-read-02-judgment-equal/,Virgil Chan,underscore.js 源码之 比较两个数相等,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/06/07/underscore-read-03-clouser-createAssigner/" title="underscore.js 源码之 闭包与 createAssigner 方法">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/06/06/underscore-read-01-type-judgment/" title="underscore.js 源码之 JavaScript 常见类型判断">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>